# 文档说明

此文档编写的目的是记录协程库`cocpp`设计开发中的思路、设计与分析。目标读者为想了解一个协程库从无到有的过程的学习人员。

# 问题定义

## 背景

目前`github`上已经有很多开源的协程实现了，如：[`libco`](https://github.com/Tencent/libco)，[`libgo`](https://github.com/Tencent/libco)，[`bthread`](https://github.com/apache/incubator-brpc)（`bthread`是`brpc`底层的一个组件）等。那么为什么还要费时费力开发一个协程库呢？我理想中的协程库是什么样的呢？

首先我先回答一下第二个问题，我理想中的协程库是什么样？

- 协程与线程`M:N`对应
  就是说协程可以在不同的线程间切换，以避免有的线程撑死，有的线程饿死的局面。
- 可选共享栈
  这个需求主要是从节省内存的目的出发，多个协程共享一个栈，在协程切换出去的时候仅保留自身使用过的一小部分栈内存。被调度时将自身的栈内存恢复。
- 死循环自动切换
  当某个协程发生死循环的时候，同一个调度线程下的协程不能被阻塞。
- 可以获取协程的返回值
  可以对协程进行等待并获取其返回值。
- 友好的接口
  最好是可以与`std::thread`类似的接口调用，减少学习成本，会用线程，就会用协程。


对于以上要求来说，目前还没有发现有协程库完全具有以上所有功能的（如果有，请务必告诉我）。上述提到的协程库仅能部分满足上述条件。

所以，现在来解答第一个问题，为什么还要费时费力开发一个协程库呢？

原因有以下几点：

- 现在的协程库达不到我的预期
- 希望通过从`0`开发一个协程库来提升自己
- 通过完整开发一个项目开规范自身的开发习惯

## 总体要求

### 功能要求

#### 主要要求

- 协程与线程关系`M:N`
- 共享栈支持
- 死循环自动切换
- 返回值可获取（协程可等待）
- 具有与`std::thread`相同或者类似的接口
- 不存在内存泄露

#### 次要要求

- 协程可分离（`detach`）
- 简单的协程通信方式（`channel`）
- 协程同步（锁、信号量）
- 协程局部存储
- 协程`ID`
- 协程状态查询

### 性能要求

- 与主流协程库的差距在一个数量级内（主要为`libco`和`libgo`，由于`bthread`与`brpc`绑定，此处暂不考虑）

### 资源要求

- 非共享模式下，除栈空间（可配置）外，每个协程额外占用的内存数量不超过`1KB`。
- 共享模式下，每个协程占用的内存数量不超过`1KB`

### 维测需求

- 协程中出现异常时，需要可以查看问题发生时的调用栈信息、栈内存数据、协程上下文数据。
- 专门的调试工具或者`gdb/lldb`的插件支持

### 开发规范要求

- 单元测试分支覆盖率`80%`以上
- 各阶段文档全面（本文档），主要包括概要设计、详细设计、测试数据（功能、性能）、构建部署说明等
- 代码开发命名良好、模块边界清晰、依赖性小。代码圈复杂度低，重复度低。
- 持续集成

### 环境要求

- 编译器需要支持`c++20`（暂定为`clang++ 10.0.0-4`）
- 操作系统为`linux`
- `CPU`架构为`AMD64`（第一版暂仅支持`AMD64`）

# 概要设计

## 模块划分

`cocpp`应该至少包含以下几个部分:

- 协程用户界面
  这里并不是指的`GUI`用户界面这个意思，而是指用户通过一个对象来访问协程对象。此对象提供协程的创建、等待、状态查询、销毁等接口。
- 协程对象
  实际的协程对象，比用户界面更多的功能与控制接口，用户界面是协程对象中暴露给用户的一部分`API`，而协程对象提供的是暴露给协程的管理对象的接口。
- 协程运行环境
  协程被执行的上下文环境，关联一个执行线程。此外，还包括了共享栈协程栈内存的管理。
- 协程运行环境管理对象
  全局唯一，主要负责协程运行环境的创建、回收，自动伸缩等。
- 调试模块
  负责与外部调试工具对接。
- 协程同步模块
  主要提供协程间的同步、互斥、等待等。
- 通信模块
  各协程间传递数据使用。
- 局部存储管理
  协程私有数据管理。
- 监控模块
  用于监控协程的执行状态，找到死循环线程等。

## 总体结构

以上的模块结构组织如下：

![模块结构](imgs/模块结构.png)

对于上层用户来说，可见的有协程用户界面，主要提供协程的创建以及用户级管理。调试模块、通信模块和同步模块。

协程运行环境管理模块负责创建、管理、监控协程的运行环境，协程运行环境为协程对象提供执行环境。协程对象中包含协程局部存储的管理。

协程运行环境管理对象中包含一个监控模块对每个协程运行环境进行监控，其监控结果将指导环境管理对象对执行环境进行伸缩、销毁等。

协程对象开放一部分`API`给协程用户界面使用，提供管理、控制等功能。同时为调试、通信和同步模块提供需要的服务。

# 详细设计

## 协程切换

为什么没有先设计协程的创建，而是先设计协程的切换呢？因为协程的创建到开始运行，其实也是一种切换，只是第一次切换没有“当前协程”这个概念。

**协程的切换其本质是协程上下文的切换，那么协程的上下文主要包含哪些内容呢？**

### 协程上下文包含的内容

- 协程栈
- 协程寄存器  

每个协程都有一个独立的栈空间和一些私有寄存器（这里的私有寄存器是指需要被调用者保存的寄存器，包括`rdi,rbp,rbx,rsp,rip,r12,r13,r14,r15`），要切换协程其实就是将当前协程的栈空间和寄存器保存下来，然后恢复要切换到的协程的栈空间和寄存器。由于`rsp`寄存器指示了当前栈空间的栈顶位置，所以只需要保存`rdi,rbp,rbx,rsp,rip,r12,r13,r14,r15`这`9`个寄存器就好了。

**知道了保存哪些内容，那么一次协程切换的步骤是什么呢？**

### 一次协程切换的步骤

我们可以使用一个大小为`9`的`void*`数组来保存这些寄存器的值。

协程切换的步骤就是将当前寄存器的值保存，将目标寄存器的值恢复，然后跳转到目标寄存器的`rip`。

流程如下：

![协程切换](imgs/协程切换.png)

图中表示要从“当前协程”切换到“下一个协程”，当前协程在运行的时候，运行环境的寄存器`rsp`保存着当前协程的栈顶位置，`rip`保存着当前协程的代码段地址。

发生切换时，第一步是保存当前执行环境，就是将当前执行环境中的相关寄存器保存到当前协程对象的存储中。
第二步是将下一个协程对象中存储的寄存器信息恢复到运行环境相应的寄存器中。

当完成这两个步骤之后，协程就完成了切换。

**目前已完成单次协程切换流程的讨论，那么，如果完成在多个协程之间切换并执行完成返回呢？**

### 在多个协程间切换并最终返回

我们将这个步骤封装为一个函数（假设为`switch_co`），在当前协程中调用，传入要切换的协程的协程对象，然后当新协程执行一段时间后，再调用此函数，传入其他协程的协程对象，这样就可以在不同的协程间切换了。搭配一定的选择策略，一个调度器的逻辑就完成了。

下面展示一个完整的协程切换的图示：

![完整协程切换](imgs/协程多次切换.png)

图中红色部分就是上面提到的切换函数`switch_co`。

1. 整个流程从一个线程开始（一开始还没有创建协程，起始的线程可以称为主协程），运行一段时间后，调用`switch_co`创建一个协程。没错，`switch_co`可以用来创建协程，我们只需要构造一个协程1的协程对象，将协程1的入口地址（假设为`co_entry1`）设置为`rip`，将协程1的栈底设置为`rsp`（或者说栈顶，一开始栈是空的，栈顶与栈底相等），再调用`switch_co`就相当于创建了一个以`co_entry1`为入口的协程。
2. 协程1运行一段时间后，又以相同的办法创建了协程2。
3. 协程2运行一段时间后，调用`switch_co`切换到主协程。
4. 主协程调用`switch_co`切换到协程1
5. 协程1运行结束，调用`switch_co`切换到协程2
6. 协程2运行结束，调用`switch_co`切换到主协程
7. 主协程运行结束，返回到上一层调用栈

**注意到上面协程1和协程2结束的时候，需要再调用一次`switch_co`，这是为什么呢？**

### 协程入口函数返回方法

因为协程的栈空间是用户分配的，切换到协程的栈空间是由`switch_co`完成的，因此，协程入口函数并没有上一级调用者，当入口函数值性结束后，栈的状态和初始的状态应该保持一致（空），如果此时进行函数返回，`CPU`会从`rsp`的位置弹出一个值作为`rip`，但是此时`rsp`指向内存的值是无效的（不是不能访问，而是说并不是指向上一级调用函数，因为不存在上级调用函数），所以会发生段错误。因此需要在协程入口函数结束的时候跳转到其他协程（且不再跳回来），最终跳转到主协程，由主协程返回上一级调用函数（主协程使用的是线程上下文，有上一级调用函数）。

协程入口函数需要最终调用`switch_co`切换到其他协程，这个步骤怎么保证呢？

### 对协程入口函数进行封装

以上讨论了协程入口返回函数需要调用`switch_co`进行切换，那么谁来保证调用呢，目前有两个选择：

- 协程创建者
  由创建者在函数返回的时候调用。
- 协程框架调用
  定义通用协程入口函数，包装用户传入的入口函数

以上两种方案中，应该选择第二种。理由如下：

1. 无法保证用户一定会在协程返回之前调用`switch_co`，写在文档中？相信我，大多数开发人员只在出错的啥时候看一眼文档。
2. 协程入口函数出现异常的时候，无法调用`switch_co`。导致程序崩溃。
3. 协程入口函数不能带有返回值。如果要在函数返回之前调用`switch_co`，那么函数就不能有返回值，即使有返回值也执行不到，而事实上，很多协程的创建就是为了计算出一个结果，供其他协程使用。没有返回值的协程，就失去了它的价值。

而使用第二种方案就可以完全解决以上问题。包装函数伪代码如下：

```cpp
void wrap_co_entry(user_co_entry, args ...) {
    try {
        result = user_co_entry(args ...);
    } catch (...) {
        // 处理异常
    }
    switch_co(this_coroutine_object, other_coroutine_object);
}
```

针对上面第一个问题，通过函数调用包装，保证在调用了用户的协程函数入口返回后调用`switch_co`，防`rsp`无效导致`rip`跳转到无效地址。

对于第二个问题，在包装函数中进行异常捕获，从而保证无论是否有没有异常，都能调用到`switch_co`。

第三个问题，可以通过调用用户入口函数并且获取返回值，并传递到外层。

综上，可以选择第二种方案，使用包装函数包装协程入口。


## 协程创建

## 协程共享栈

## 协程同步

## 协程等待

## 协程状态

## 协程转移

## 协程分离

## 协程销毁

## 协程通信

## 协程局部存储

## 协程ID

## 用户接口

# 测试数据

# 构建部署说明

# 未来规划